(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{409:function(v,_,t){"use strict";t.r(_);var l=t(54),n=Object(l.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"第22章-动态规划"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第22章-动态规划"}},[v._v("#")]),v._v(" 第22章 动态规划")]),v._v(" "),t("p",[v._v("动态规划（dynamic programming, DP）是一种将复杂问题分解成更小的子问题来解决的优化技术。")]),v._v(" "),t("blockquote",[t("p",[v._v("注意，动态规划和分而治之是不同的方法。分而治之方法是把问题分解成相互独立的子问题，然后组合它们的答案，而动态规划则是将问题分解成相互依赖的子问题。")])]),v._v(" "),t("p",[v._v("动态规划的一个例子是第11章解决的斐波那契问题。我们将斐波那契问题分解成了一些小问题。")]),v._v(" "),t("p",[v._v("用动态规划解决问题时，要遵循三个重要步骤：")]),v._v(" "),t("ol",[t("li",[v._v("定义子问题；")]),v._v(" "),t("li",[v._v("实现要反复执行来解决子问题的部分（这一步要参考前一节讨论的递归的步骤）；")]),v._v(" "),t("li",[v._v("识别并求解出基线条件。")])]),v._v(" "),t("p",[v._v("能用动态规划解决的一些著名问题如下。")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("背包问题")]),v._v("：给出一组项，各自有值和容量，目标是找出总值最大的项的集合。这个问题的限制是，总容量必须小于等于“背包”的容量。")]),v._v(" "),t("li",[t("strong",[v._v("最长公共子序列")]),v._v("：找出一组序列的最长公共子序列（可由另一序列删除元素但不改变余下元素的顺序而得到）。")]),v._v(" "),t("li",[t("strong",[v._v("矩阵链相乘")]),v._v("：给出一系列矩阵，目标是找到这些矩阵相乘的最高效办法（计算次数尽可能少）。相乘运算不会进行，解决方案是找到这些矩阵各自相乘的顺序。")]),v._v(" "),t("li",[t("strong",[v._v("硬币找零")]),v._v("：给出面额为d1, …, dn的一定数量的硬币和要找零的钱数，找出有多少种找零的方法。")]),v._v(" "),t("li",[t("strong",[v._v("图的全源最短路径")]),v._v("：对所有顶点对(u, v)，找出从顶点u到顶点v的最短路径。我们在第17章已经学习过这个问题的Floyd-Warshall算法。")])])])}),[],!1,null,null,null);_.default=n.exports}}]);